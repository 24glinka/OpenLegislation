package gov.nysenate.openleg.dao.base;

import com.google.common.base.Splitter;
import com.google.common.primitives.Ints;
import gov.nysenate.openleg.model.search.SearchResult;
import gov.nysenate.openleg.model.search.SearchResults;
import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;
import org.elasticsearch.action.admin.indices.exists.indices.IndicesExistsRequest;
import org.elasticsearch.action.search.SearchRequestBuilder;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.search.SearchType;
import org.elasticsearch.client.Client;
import org.elasticsearch.index.query.FilterBuilder;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.sort.SortBuilder;
import org.elasticsearch.search.sort.SortBuilders;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import javax.annotation.PostConstruct;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

/**
 * Base class for Elastic Search layer classes to inherit common functionality from.
 */
public abstract class ElasticBaseDao
{
    private static final Logger logger = LoggerFactory.getLogger(ElasticBaseDao.class);

    @Autowired
    protected Client searchClient;

    @PostConstruct
    private void init() {}

    /** --- Common Elastic Search methods --- */

    /**
     * Generates a typical search request that involves a query, filter, sort string, and a limit + offset
     *
     * @param indexName the name of the index to perform a search on
     * @param query an elastic search Query DSL
     * @param postFilter
     * @param sort
     * @param limitOffset
     * @return SearchRequestBuilder
     */
    protected SearchRequestBuilder getSearchRequest(String indexName, QueryBuilder query, FilterBuilder postFilter,
                                                    String sort, LimitOffset limitOffset) {
        SearchRequestBuilder searchBuilder = searchClient.prepareSearch(indexName)
            .setSearchType(SearchType.QUERY_THEN_FETCH)
            .setQuery(query)
            .setFrom(limitOffset.getOffsetStart() - 1)
            .setSize((limitOffset.hasLimit()) ? limitOffset.getLimit() : -1)
            .setFetchSource(false);
        // Post filters take effect after the search is completed
        if (postFilter != null) {
            searchBuilder.setPostFilter(postFilter);
        }
        // Add the sort by fields
        extractSortFilters(sort).forEach(searchBuilder::addSort);
        return searchBuilder;
    }

    /**
     * Extracts search results from a search response
     *
     * @param response a SearchResponse generated by a SearchRequest
     * @param limitOffset the LimitOffset used in the SearchRequest
     * @param hitMapper a function that maps a SearchHit to the desired return type R
     * @param <R> the desired return type
     * @return
     */
    protected <R> SearchResults<R> getSearchResults(SearchResponse response, LimitOffset limitOffset,
                                                    Function<SearchHit, R> hitMapper) {
        List<SearchResult<R>> resultList = new ArrayList<>();
        for (SearchHit hit : response.getHits().hits()) {
            SearchResult<R> result = new SearchResult<>(
                    hitMapper.apply(hit),
                    (!Float.isNaN(hit.getScore())) ? BigDecimal.valueOf(hit.getScore()) : BigDecimal.ONE);
            resultList.add(result);
        }
        return new SearchResults<>(Ints.checkedCast(response.getHits().getTotalHits()), resultList, limitOffset);
    }

    /**
     * Generates a list of elastic search sort parameters from a CSV string.  If no parameters are specified,
     *  a single score sort parameter is used.
     *
     * @param sort
     * @return
     */
    protected List<SortBuilder> extractSortFilters(String sort) {
        List<SortBuilder> sortBuilders = new ArrayList<>();
        if (sort == null || sort.trim().isEmpty()) {
            sortBuilders.add(SortBuilders.scoreSort());
        }
        else {
            Map<String, String> sortMap =
                Splitter.on(",").omitEmptyStrings().trimResults().withKeyValueSeparator(":").split(sort);
            sortMap.forEach((k,v) -> sortBuilders.add(
                SortBuilders.fieldSort(k).order(org.elasticsearch.search.sort.SortOrder.valueOf(v.toUpperCase()))));
        }
        return sortBuilders;
    }

    protected boolean indicesExist(String... indices) {
        return searchClient.admin().indices().exists(new IndicesExistsRequest(indices)).actionGet().isExists();
    }

    protected void createIndex(String indexName) {
        searchClient.admin().indices().prepareCreate(indexName).execute().actionGet();
    }

    protected void deleteIndex(String index) {
        searchClient.admin().indices().delete(new DeleteIndexRequest(index)).actionGet();
    }
}
